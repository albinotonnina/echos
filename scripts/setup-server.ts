#!/usr/bin/env -S pnpm tsx

/**
 * EchOS Web Setup Server
 *
 * Zero-dependency (uses only Node.js built-ins) server that serves a
 * browser-based setup wizard. Writes .env and creates data directories.
 *
 * Usage:
 *   pnpm wizard              # starts server + opens browser
 *   pnpm wizard --port 3456  # custom port
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import * as http from 'node:http';
import { randomBytes } from 'node:crypto';
import { createConnection } from 'node:net';
import { exec } from 'node:child_process';
import { homedir } from 'node:os';
import { fileURLToPath } from 'node:url';

/** Expand a leading `~` to the user's home directory. */
function expandTilde(p: string): string {
  if (p === '~') return homedir();
  if (p.startsWith('~/')) return path.join(homedir(), p.slice(2));
  return p;
}

/** Escape a string for safe embedding in HTML attributes/content. */
function escapeHtml(s: string): string {
  return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

const DEFAULT_ECHOS_HOME = path.resolve(expandTilde(process.env['ECHOS_HOME'] || path.join(homedir(), 'echos')));

/** CSRF token required for all POST requests. */
const CSRF_TOKEN = randomBytes(32).toString('hex');

const args = process.argv.slice(2);

// Detect Homebrew install by checking if this script lives under a Homebrew
// libexec directory, rather than relying on PATH (which could misclassify a
// source checkout on a machine that also has a Homebrew install).
const IS_BREW_INSTALL = (() => {
  try {
    const scriptPath = fs.realpathSync(fileURLToPath(import.meta.url));
    const libexecSeg = `${path.sep}libexec${path.sep}`;
    return scriptPath.includes(libexecSeg);
  } catch {
    return false;
  }
})();

const PORT = (() => {
  const portArgIndex = args.indexOf('--port');
  if (portArgIndex === -1) return 3456;

  const rawPort = args[portArgIndex + 1];
  if (!rawPort || rawPort.startsWith('-')) {
    console.error('Error: --port flag requires a numeric value.\nUsage: pnpm wizard --port 3456');
    process.exit(1);
  }

  const parsedPort = parseInt(rawPort, 10);
  if (!Number.isInteger(parsedPort) || parsedPort <= 0 || parsedPort > 65535) {
    console.error(`Error: Invalid port "${rawPort}". Port must be an integer between 1 and 65535.`);
    process.exit(1);
  }

  return parsedPort;
})();

// ─── Helpers ──────────────────────────────────────────────────────────────────

function parseEnvFile(content: string): Record<string, string> {
  const result: Record<string, string> = {};
  for (const line of content.split('\n')) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    const eq = trimmed.indexOf('=');
    if (eq === -1) continue;
    const key = trimmed.slice(0, eq).trim();
    const raw = trimmed.slice(eq + 1).trim();
    const value = raw.replace(/^(['"])(.*)\1$/, '$2');
    result[key] = value;
  }
  return result;
}

function sanitizeEnvValue(value: string): string {
  // Strip newlines/carriage returns to prevent env injection
  return value.replace(/[\r\n]/g, '');
}

/** Quote env values that contain special chars to prevent silent truncation */
function quoteEnvValue(value: string): string {
  if (!value) return '';
  const sanitized = sanitizeEnvValue(value);
  if (/[\s#'"\\]/.test(sanitized)) {
    return `"${sanitized.replace(/["\\]/g, '\\$&')}"`;
  }
  return sanitized;
}

function stateToEnv(state: Record<string, unknown>): string {
  const s = (k: string): string => quoteEnvValue(String(state[k] ?? ''));
  const home = String(state['echosHome'] || DEFAULT_ECHOS_HOME);
  const lines: string[] = [
    '# EchOS Configuration — generated by echos setup',
    `# Created: ${new Date().toISOString()}`,
    '',
    '# ── Required ────────────────────────────────────────────────────────────────',
    `ANTHROPIC_API_KEY=${s('anthropicApiKey')}`,
    `ALLOWED_USER_IDS=${s('allowedUserIds')}`,
    '',
    '# ── OpenAI (optional, for embeddings and Whisper) ───────────────────────────',
    s('openaiApiKey') ? `OPENAI_API_KEY=${s('openaiApiKey')}` : '# OPENAI_API_KEY=',
    '',
    '# ── Interfaces ───────────────────────────────────────────────────────────────',
    `ENABLE_TELEGRAM=${s('enableTelegram')}`,
    `ENABLE_WEB=${s('enableWeb')}`,
    `WEB_PORT=${s('webPort') || '3000'}`,
    s('webApiKey') ? `WEB_API_KEY=${s('webApiKey')}` : '# WEB_API_KEY=',
    '',
    '# ── Telegram (required when ENABLE_TELEGRAM=true) ───────────────────────────',
    s('telegramBotToken') ? `TELEGRAM_BOT_TOKEN=${s('telegramBotToken')}` : '# TELEGRAM_BOT_TOKEN=',
    '',
    '# ── Storage ──────────────────────────────────────────────────────────────────',
    `KNOWLEDGE_DIR=${quoteEnvValue(String(state['knowledgeDir'] || path.join(home, 'knowledge')))}`,
    `DB_PATH=${quoteEnvValue(String(state['dbPath'] || path.join(home, 'db')))}`,
    `SESSION_DIR=${quoteEnvValue(String(state['sessionDir'] || path.join(home, 'sessions')))}`,
    '',
    '# ── Redis (required) ─────────────────────────────────────────────────────────',
    `REDIS_URL=${s('redisUrl') || 'redis://localhost:6379'}`,
    '',
    '# ── Models ───────────────────────────────────────────────────────────────────',
    `DEFAULT_MODEL=${s('defaultModel') || 'claude-haiku-4-5-20251001'}`,
    `EMBEDDING_MODEL=${s('embeddingModel') || 'text-embedding-3-small'}`,
    '',
    '# ── Webshare Proxy (optional, for YouTube on cloud IPs) ─────────────────────',
    s('webshareProxyUsername') ? `WEBSHARE_PROXY_USERNAME=${s('webshareProxyUsername')}` : '# WEBSHARE_PROXY_USERNAME=',
    s('webshareProxyPassword') ? `WEBSHARE_PROXY_PASSWORD=${s('webshareProxyPassword')}` : '# WEBSHARE_PROXY_PASSWORD=',
    '',
  ];
  return lines.join('\n');
}

function readBody(req: http.IncomingMessage): Promise<string> {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    req.on('data', (chunk: Buffer) => chunks.push(chunk));
    req.on('end', () => resolve(Buffer.concat(chunks).toString()));
    req.on('error', reject);
  });
}

function json(res: http.ServerResponse, data: unknown, status = 200): void {
  res.writeHead(status, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify(data));
}

// ─── Validation handlers ──────────────────────────────────────────────────────

async function validateAnthropic(body: { key: string }): Promise<{ valid: boolean; error?: string }> {
  if (!body.key?.startsWith('sk-ant-')) {
    return { valid: false, error: 'Key should start with sk-ant-' };
  }
  try {
    const resp = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      signal: AbortSignal.timeout(10000),
      headers: {
        'x-api-key': body.key,
        'anthropic-version': '2023-06-01',
        'content-type': 'application/json',
      },
      body: JSON.stringify({
        model: 'claude-haiku-4-5-20251001',
        max_tokens: 1,
        messages: [{ role: 'user', content: 'Hi' }],
      }),
    });
    if (resp.status === 401) return { valid: false, error: 'API key rejected (401)' };
    if (resp.status === 400 || resp.ok) return { valid: true };
    return { valid: false, error: `Unexpected status ${resp.status}` };
  } catch (err: unknown) {
    return { valid: false, error: `Network error: ${err instanceof Error ? err.message : String(err)}` };
  }
}

async function validateOpenai(body: { key: string }): Promise<{ valid: boolean; error?: string }> {
  try {
    const resp = await fetch('https://api.openai.com/v1/models', {
      signal: AbortSignal.timeout(10000),
      headers: { Authorization: `Bearer ${body.key}` },
    });
    if (resp.status === 401) return { valid: false, error: 'API key rejected (401)' };
    if (resp.ok) return { valid: true };
    return { valid: false, error: `Unexpected status ${resp.status}` };
  } catch (err: unknown) {
    return { valid: false, error: `Network error: ${err instanceof Error ? err.message : String(err)}` };
  }
}

async function validateTelegram(body: { token: string }): Promise<{ valid: boolean; botName?: string; error?: string }> {
  try {
    const resp = await fetch(`https://api.telegram.org/bot${body.token}/getMe`, {
      signal: AbortSignal.timeout(10000),
    });
    const data = (await resp.json()) as { ok: boolean; result?: { username?: string } };
    if (data.ok) return { valid: true, botName: data.result?.username };
    return { valid: false, error: 'Bot token rejected by Telegram' };
  } catch (err: unknown) {
    return { valid: false, error: `Network error: ${err instanceof Error ? err.message : String(err)}` };
  }
}

function validateRedis(body: { url: string }): Promise<{ valid: boolean; error?: string }> {
  return new Promise((resolve) => {
    try {
      const parsed = new URL(body.url);
      const port = parseInt(parsed.port || '6379', 10);
      const host = parsed.hostname || 'localhost';
      const conn = createConnection({ host, port });
      conn.setTimeout(5000);
      conn.on('connect', () => { conn.destroy(); resolve({ valid: true }); });
      conn.on('error', (err) => { conn.destroy(); resolve({ valid: false, error: err.message }); });
      conn.on('timeout', () => { conn.destroy(); resolve({ valid: false, error: 'Connection timed out' }); });
    } catch (err: unknown) {
      resolve({ valid: false, error: `Invalid URL: ${err instanceof Error ? err.message : String(err)}` });
    }
  });
}

function writeConfig(state: Record<string, unknown>): { success: boolean; error?: string } {
  try {
    const rawHome = String(state['echosHome'] || DEFAULT_ECHOS_HOME);
    const echosHome = path.resolve(expandTilde(rawHome));

    // Validate: must be an absolute path under (not equal to) the user's home directory.
    // Use realpathSync to resolve symlinks so a symlinked path can't bypass the check.
    const realHome = fs.realpathSync(homedir());
    const realEchosHome = fs.existsSync(echosHome) ? fs.realpathSync(echosHome) : echosHome;
    if (realEchosHome === realHome) {
      return { success: false, error: 'Data directory must be a subdirectory of your home directory (e.g. ~/echos), not the home directory itself' };
    }
    if (!realEchosHome.startsWith(realHome + path.sep)) {
      return { success: false, error: 'Data directory must be under your home directory' };
    }

    const envPath = path.join(echosHome, '.env');

    // Ensure ECHOS_HOME exists
    if (!fs.existsSync(echosHome)) {
      fs.mkdirSync(echosHome, { recursive: true });
    }

    // Backup existing .env
    if (fs.existsSync(envPath)) {
      const backupPath = `${envPath}.backup.${Date.now()}`;
      fs.copyFileSync(envPath, backupPath);
      fs.chmodSync(backupPath, 0o600);
    }

    // Derive storage paths server-side from the validated echosHome
    // (ignore any client-provided values to prevent path traversal)
    const knowledgeDir = path.join(echosHome, 'knowledge');
    const dbPath = path.join(echosHome, 'db');
    const sessionDir = path.join(echosHome, 'sessions');
    state['knowledgeDir'] = knowledgeDir;
    state['dbPath'] = dbPath;
    state['sessionDir'] = sessionDir;

    const content = stateToEnv(state);
    fs.writeFileSync(envPath, content, { encoding: 'utf8', mode: 0o600 });
    fs.chmodSync(envPath, 0o600);

    // Create data directories
    const dirs = [knowledgeDir, dbPath, sessionDir];
    for (const dir of dirs) {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    }

    // Persist ECHOS_HOME so Homebrew wrappers can find it
    const configDir = path.join(home, '.config', 'echos');
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }
    const homeConfigPath = path.join(configDir, 'home');
    fs.writeFileSync(homeConfigPath, echosHome, { encoding: 'utf8', mode: 0o600 });
    fs.chmodSync(homeConfigPath, 0o600);

    return { success: true };
  } catch (err: unknown) {
    return { success: false, error: err instanceof Error ? err.message : String(err) };
  }
}

// ─── HTTP server ──────────────────────────────────────────────────────────────

// Track open sockets so we can destroy them on shutdown (browsers keep-alive)
const openSockets = new Set<import('node:net').Socket>();

const server = http.createServer(async (req, res) => {
  const url = new URL(req.url || '/', `http://localhost:${PORT}`);

  // Only allow localhost — validate both remote address and host header
  // to prevent DNS rebinding attacks (e.g. localhost.evil.com)
  const remoteAddr = req.socket.remoteAddress || '';
  if (!['127.0.0.1', '::1', '::ffff:127.0.0.1'].includes(remoteAddr)) {
    res.writeHead(403);
    res.end('Forbidden');
    return;
  }
  const host = req.headers.host || '';
  if (!/^(localhost|127\.0\.0\.1)(:\d+)?$/.test(host)) {
    res.writeHead(403);
    res.end('Forbidden');
    return;
  }

  try {
    // Routes
    if (req.method === 'GET' && (url.pathname === '/' || url.pathname === '/setup')) {
      res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
      res.end(getSetupHtml());
      return;
    }

    if (req.method === 'GET' && url.pathname === '/api/setup/existing') {
      // Resolve the actual ECHOS_HOME: check persisted config, then env, then default
      let echosHomeForExisting = DEFAULT_ECHOS_HOME;
      const persistedHomePath = path.join(homedir(), '.config', 'echos', 'home');
      if (fs.existsSync(persistedHomePath)) {
        const persisted = fs.readFileSync(persistedHomePath, 'utf8').trim();
        if (persisted) {
          const expanded = expandTilde(persisted);
          const resolved = path.resolve(expanded);
          const realUserHome = fs.realpathSync(homedir());
          const realResolved = fs.existsSync(resolved) ? fs.realpathSync(resolved) : resolved;
          const isUnderHome =
            realResolved.startsWith(realUserHome + path.sep);
          if (isUnderHome) {
            echosHomeForExisting = resolved;
          }
        }
      }
      const envPath = path.join(echosHomeForExisting, '.env');
      if (!fs.existsSync(envPath)) {
        json(res, { exists: false, config: {} });
        return;
      }
      const content = fs.readFileSync(envPath, 'utf8');
      const parsed = parseEnvFile(content);
      const masked: Record<string, string> = {};
      for (const [k, v] of Object.entries(parsed)) {
        if (k.includes('KEY') || k.includes('TOKEN') || k.includes('PASSWORD')) {
          masked[k] = v ? `${v.slice(0, 6)}...${v.slice(-4)}` : '';
        } else {
          masked[k] = v;
        }
      }
      json(res, { exists: true, config: masked });
      return;
    }

    if (req.method === 'POST') {
      // Verify CSRF token
      if (req.headers['x-csrf-token'] !== CSRF_TOKEN) {
        json(res, { error: 'Invalid CSRF token' }, 403);
        return;
      }

      let body: Record<string, unknown>;
      try {
        body = JSON.parse(await readBody(req)) as Record<string, unknown>;
      } catch {
        json(res, { error: 'Invalid JSON in request body' }, 400);
        return;
      }

      if (url.pathname === '/api/setup/validate-anthropic') {
        const key = body['key'];
        if (typeof key !== 'string') { json(res, { error: 'Missing or invalid "key"' }, 400); return; }
        json(res, await validateAnthropic({ key }));
        return;
      }
      if (url.pathname === '/api/setup/validate-openai') {
        const key = body['key'];
        if (typeof key !== 'string') { json(res, { error: 'Missing or invalid "key"' }, 400); return; }
        json(res, await validateOpenai({ key }));
        return;
      }
      if (url.pathname === '/api/setup/validate-telegram') {
        const token = body['token'];
        if (typeof token !== 'string') { json(res, { error: 'Missing or invalid "token"' }, 400); return; }
        json(res, await validateTelegram({ token }));
        return;
      }
      if (url.pathname === '/api/setup/validate-redis') {
        const redisUrl = body['url'];
        if (typeof redisUrl !== 'string') { json(res, { error: 'Missing or invalid "url"' }, 400); return; }
        json(res, await validateRedis({ url: redisUrl }));
        return;
      }
      if (url.pathname === '/api/setup/generate-key') {
        json(res, { key: randomBytes(32).toString('hex') });
        return;
      }
      if (url.pathname === '/api/setup/write-config') {
        json(res, writeConfig(body));
        return;
      }
      if (url.pathname === '/api/setup/start-service') {
        // Only allow on Homebrew installs — the endpoint runs `brew services`
        if (!IS_BREW_INSTALL) {
          json(res, { success: false, error: 'Start-service is only available for Homebrew installs' }, 400);
          return;
        }

        // CSRF protection: validate Origin header to prevent cross-origin triggers
        const origin = req.headers.origin || '';
        const referer = req.headers.referer || '';
        const allowedOrigins = [`http://localhost:${PORT}`, `http://127.0.0.1:${PORT}`];
        const originOk = allowedOrigins.some((o) => origin === o);
        const refererOk = allowedOrigins.some((o) => referer.startsWith(o));
        if (!originOk && !refererOk) {
          json(res, { success: false, error: 'Invalid request origin' }, 403);
          return;
        }

        const startRedis = () =>
          new Promise<{ success: boolean; error?: string }>((resolve) => {
            exec('brew services start redis', { timeout: 10000 }, (err, stdout, stderr) => {
              if (err) {
                const detail = [err.message, stderr?.trim(), stdout?.trim()].filter(Boolean).join(' — ');
                resolve({ success: false, error: `Redis failed to start: ${detail}` });
              } else {
                resolve({ success: true });
              }
            });
          });
        const startEchos = () =>
          new Promise<{ success: boolean; error?: string }>((resolve) => {
            exec('brew services start echos', { timeout: 15000 }, (err, stdout, stderr) => {
              if (err) {
                const detail = [err.message, stderr?.trim(), stdout?.trim()].filter(Boolean).join(' — ');
                resolve({ success: false, error: `EchOS failed to start: ${detail}` });
              } else {
                resolve({ success: true });
              }
            });
          });
        const redisResult = await startRedis();
        if (!redisResult.success) {
          json(res, redisResult);
          return;
        }
        const result = await startEchos();
        if (result.success) {
          // Shut down setup server after a short delay — it's no longer needed
          setTimeout(() => {
            server.close(() => {
              process.exit(0);
            });
            // Destroy lingering keep-alive connections so server.close() can finish
            for (const socket of openSockets) {
              socket.destroy();
            }
            // Hard-exit fallback in case server.close() callback never fires
            setTimeout(() => process.exit(0), 5000).unref();
          }, 3000);
        }
        // Inline response with Connection: close to unblock server.close()
        res.writeHead(200, {
          'Content-Type': 'application/json',
          Connection: 'close',
        });
        res.end(JSON.stringify(result));
        return;
      }
    }

    res.writeHead(404);
    res.end('Not found');
  } catch (err: unknown) {
    console.error('Request error:', err);
    json(res, { error: 'Internal server error' }, 500);
  }
});

// ─── Setup HTML ───────────────────────────────────────────────────────────────

function getSetupHtml(): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EchOS Setup</title>
  <style>
    :root {
      --bg: #0a0a0a; --surface: #141414; --border: #2a2a2a;
      --text: #e0e0e0; --text-dim: #888;
      --accent: #06b6d4; --accent-hover: #22d3ee;
      --success: #22c55e; --warning: #eab308; --error: #ef4444;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
      background: var(--bg); color: var(--text);
      min-height: 100vh; display: flex; justify-content: center; padding: 2rem 1rem;
    }
    .container { width: 100%; max-width: 640px; }
    h1 { font-size: 1.5rem; margin-bottom: 0.25rem; color: var(--accent); }
    .subtitle { color: var(--text-dim); font-size: 0.875rem; margin-bottom: 2rem; }
    .step { display: none; animation: fadeIn 0.2s ease; }
    .step.active { display: block; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
    .step-header { font-size: 1.125rem; font-weight: 600; margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem; }
    .step-number { background: var(--accent); color: var(--bg); width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.75rem; font-weight: 700; }
    .step-desc { color: var(--text-dim); font-size: 0.8rem; margin-bottom: 1.5rem; }
    .step-desc a { color: var(--accent); }
    .field { margin-bottom: 1.25rem; }
    label { display: block; font-size: 0.8rem; font-weight: 500; margin-bottom: 0.375rem; }
    .label-hint { color: var(--text-dim); font-weight: 400; }
    input[type="text"], input[type="password"], input[type="number"] {
      width: 100%; padding: 0.625rem 0.75rem; background: var(--surface);
      border: 1px solid var(--border); border-radius: 6px; color: var(--text);
      font-size: 0.875rem; font-family: monospace; outline: none; transition: border-color 0.15s;
    }
    input:focus { border-color: var(--accent); }
    input::placeholder { color: #555; }
    .toggle-row {
      display: flex; align-items: center; justify-content: space-between;
      padding: 0.75rem; background: var(--surface); border: 1px solid var(--border);
      border-radius: 6px; margin-bottom: 1rem; cursor: pointer;
    }
    .toggle-row:hover, .toggle-row:focus-visible { border-color: var(--accent); outline: none; }
    .toggle-label { font-size: 0.875rem; }
    .toggle-hint { font-size: 0.75rem; color: var(--text-dim); }
    .toggle {
      position: relative; width: 42px; height: 24px; background: var(--border);
      border-radius: 12px; transition: background 0.2s; cursor: pointer; flex-shrink: 0;
    }
    .toggle.on { background: var(--accent); }
    .toggle::after {
      content: ''; position: absolute; top: 2px; left: 2px; width: 20px; height: 20px;
      background: white; border-radius: 50%; transition: transform 0.2s;
    }
    .toggle.on::after { transform: translateX(18px); }
    .validation { font-size: 0.75rem; margin-top: 0.375rem; min-height: 1.25rem; }
    .validation.success { color: var(--success); }
    .validation.error { color: var(--error); }
    .validation.loading { color: var(--text-dim); }
    .nav { display: flex; justify-content: space-between; margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid var(--border); }
    button { padding: 0.625rem 1.5rem; border-radius: 6px; font-size: 0.875rem; font-weight: 500; cursor: pointer; border: none; transition: all 0.15s; }
    .btn-primary { background: var(--accent); color: var(--bg); }
    .btn-primary:hover { background: var(--accent-hover); }
    .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-secondary { background: transparent; color: var(--text-dim); border: 1px solid var(--border); }
    .btn-secondary:hover { border-color: var(--text-dim); color: var(--text); }
    .btn-validate { padding: 0.375rem 0.75rem; font-size: 0.75rem; background: var(--surface); color: var(--text-dim); border: 1px solid var(--border); border-radius: 4px; cursor: pointer; margin-top: 0.375rem; }
    .btn-validate:hover { border-color: var(--accent); color: var(--accent); }
    .progress { display: flex; gap: 0.5rem; margin-bottom: 2rem; }
    .progress-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--border); transition: background 0.2s; }
    .progress-dot.active { background: var(--accent); }
    .progress-dot.done { background: var(--success); }
    .summary-table { width: 100%; font-size: 0.8rem; margin-bottom: 1.5rem; border-collapse: collapse; }
    .summary-table tr { border-bottom: 1px solid var(--border); }
    .summary-table td { padding: 0.5rem 0; vertical-align: top; }
    .summary-table td:first-child { color: var(--text-dim); width: 140px; white-space: nowrap; }
    .summary-table td:last-child { font-family: monospace; word-break: break-all; }
    .masked { color: var(--text-dim); }
    .badge { display: inline-block; padding: 0.125rem 0.5rem; border-radius: 4px; font-size: 0.7rem; font-weight: 600; }
    .badge-on { background: rgba(6,182,212,0.15); color: var(--accent); }
    .badge-off { background: rgba(136,136,136,0.15); color: var(--text-dim); }
    .success-screen { text-align: center; padding: 3rem 0; }
    .success-screen h2 { color: var(--success); font-size: 1.25rem; margin-bottom: 1rem; }
    .success-screen code { display: block; background: var(--surface); padding: 1rem; border-radius: 6px; margin: 0.5rem 0; font-family: monospace; font-size: 0.875rem; color: var(--accent); }
    .btn-start { display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.875rem 2rem; font-size: 1rem; font-weight: 600; background: var(--success); color: var(--bg); border: none; border-radius: 8px; cursor: pointer; transition: all 0.15s; margin: 1.5rem 0; }
    .btn-start:hover { filter: brightness(1.1); transform: translateY(-1px); }
    .btn-start:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
    .start-status { font-size: 0.8rem; margin-top: 0.5rem; min-height: 1.5rem; }
    .cli-tip { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 1.25rem; margin-top: 2rem; text-align: left; }
    .cli-tip-label { font-size: 0.75rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.5rem; }
    .cli-tip code { text-align: left; margin: 0; }
    .collapsible-header { cursor: pointer; user-select: none; display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 0; color: var(--text-dim); font-size: 0.8rem; }
    .collapsible-header:hover { color: var(--text); }
    .collapsible-content { display: none; margin-top: 0.5rem; }
    .collapsible-content.open { display: block; }
    .arrow { transition: transform 0.2s; display: inline-block; }
    .arrow.open { transform: rotate(90deg); }
  </style>
</head>
<body>
  <div class="container">
    <h1>EchOS Setup</h1>
    <p class="subtitle">Configure your personal knowledge management system</p>
    <div class="progress" id="progress"></div>

    <!-- Step 1: Data Location -->
    <div class="step active" id="step-1">
      <div class="step-header"><span class="step-number">1</span> Data Location</div>
      <p class="step-desc">Choose where EchOS stores your notes, database, and config. This folder will be visible in Finder — you can point Obsidian or other tools at the knowledge subfolder.</p>
      <div class="field">
        <label>EchOS Home <span class="label-hint">(directory path)</span></label>
        <input type="text" id="echosHome" placeholder="${escapeHtml(DEFAULT_ECHOS_HOME)}">
        <div class="validation" id="echos-home-hint" style="color:var(--text-dim)">Subdirectories: knowledge/, db/, sessions/</div>
      </div>
    </div>

    <!-- Step 2: API Keys -->
    <div class="step" id="step-2">
      <div class="step-header"><span class="step-number">2</span> API Keys</div>
      <p class="step-desc">Connect to AI providers. Anthropic is required; OpenAI is optional (embeddings + Whisper transcription).</p>
      <div class="field">
        <label>Anthropic API Key <span class="label-hint">(required, starts with sk-ant-)</span></label>
        <input type="password" id="anthropicApiKey" placeholder="sk-ant-..." autocomplete="off">
        <button class="btn-validate" onclick="validateKey('anthropic')">Test key</button>
        <div class="validation" id="anthropic-status"></div>
      </div>
      <div class="field">
        <label>OpenAI API Key <span class="label-hint">(optional)</span></label>
        <input type="password" id="openaiApiKey" placeholder="sk-..." autocomplete="off">
        <button class="btn-validate" onclick="validateKey('openai')">Test key</button>
        <div class="validation" id="openai-status"></div>
      </div>
    </div>

    <!-- Step 3: Telegram -->
    <div class="step" id="step-3">
      <div class="step-header"><span class="step-number">3</span> Telegram Bot</div>
      <p class="step-desc">Set up your Telegram bot for messaging. Create one via <a href="https://t.me/BotFather" target="_blank">@BotFather</a>.</p>
      <div class="toggle-row" role="button" tabindex="0" id="btn-enableTelegram" aria-pressed="true" onclick="toggle('enableTelegram')" onkeydown="if(event.key==='Enter'||event.key===' '){toggle('enableTelegram');event.preventDefault();}">
        <div><div class="toggle-label">Enable Telegram</div><div class="toggle-hint">Recommended primary interface</div></div>
        <div class="toggle on" id="toggle-enableTelegram"></div>
      </div>
      <div id="telegram-fields">
        <div class="field">
          <label>Bot Token <span class="label-hint">(from @BotFather)</span></label>
          <input type="password" id="telegramBotToken" placeholder="123456789:ABCdef..." autocomplete="off">
          <button class="btn-validate" onclick="validateKey('telegram')">Test token</button>
          <div class="validation" id="telegram-status"></div>
        </div>
        <div class="field">
          <label>Allowed User IDs <span class="label-hint">(required, comma-separated)</span></label>
          <input type="text" id="allowedUserIds" placeholder="123456789,987654321">
          <div class="validation" id="userid-hint" style="color:var(--text-dim)">Required for access control. Get your ID from <a href="https://t.me/userinfobot" target="_blank" style="color:var(--accent)">@userinfobot</a></div>
        </div>
      </div>
    </div>

    <!-- Step 4: Features -->
    <div class="step" id="step-4">
      <div class="step-header"><span class="step-number">4</span> Features</div>
      <p class="step-desc">Enable additional interfaces and background features.</p>
      <div class="toggle-row" role="button" tabindex="0" id="btn-enableWeb" aria-pressed="false" onclick="toggle('enableWeb')" onkeydown="if(event.key==='Enter'||event.key===' '){toggle('enableWeb');event.preventDefault();}">
        <div><div class="toggle-label">Web UI</div><div class="toggle-hint">REST API + web interface (experimental)</div></div>
        <div class="toggle" id="toggle-enableWeb"></div>
      </div>
      <div id="web-fields" style="display:none">
        <div class="field"><label>Web Port</label><input type="number" id="webPort" value="3000"></div>
      </div>
      <div class="field">
        <label>Redis URL <span class="label-hint">(required — background scheduler)</span></label>
        <input type="text" id="redisUrl" value="redis://localhost:6379">
        <button class="btn-validate" onclick="validateKey('redis')">Test connection</button>
        <div class="validation" id="redis-status"></div>
      </div>
      <div class="collapsible-header" onclick="toggleCollapsible('advanced')">
        <span class="arrow" id="arrow-advanced">&#9654;</span> Advanced options
      </div>
      <div class="collapsible-content" id="collapsible-advanced">
        <div class="field"><label>Webshare Proxy Username <span class="label-hint">(optional, for YouTube on VPS)</span></label><input type="text" id="webshareProxyUsername"></div>
        <div class="field"><label>Webshare Proxy Password</label><input type="password" id="webshareProxyPassword"></div>
      </div>
    </div>

    <!-- Step 5: Summary -->
    <div class="step" id="step-5">
      <div class="step-header"><span class="step-number">5</span> Review & Confirm</div>
      <p class="step-desc">Review your configuration before writing to .env</p>
      <table class="summary-table" id="summary-table"></table>
    </div>

    <!-- Step 6: Success -->
    <div class="step" id="step-6">
      <div class="success-screen">
        <h2>Setup Complete</h2>
        <p style="color:var(--text-dim);margin-bottom:0.5rem">Your .env file has been written and data directories created.</p>
        ${IS_BREW_INSTALL ? `
        <button class="btn-start" id="btn-start-service" onclick="startService()">
          <span id="start-icon">▶</span> Start EchOS
        </button>
        <div class="start-status" id="start-status"></div>
        ` : ''}
        <div class="cli-tip">
          ${IS_BREW_INSTALL ? `
          <div class="cli-tip-label">You can also use the CLI anytime</div>
          <code>echos "search my notes"</code>
          ` : `
          <div class="cli-tip-label">Start EchOS</div>
          <code>pnpm start</code>
          <div class="cli-tip-label" style="margin-top:1rem">Or use the CLI (no daemon needed)</div>
          <code>pnpm echos "search my notes"</code>
          `}
        </div>
      </div>
    </div>

    <div class="nav" id="nav">
      <button class="btn-secondary" id="btn-back" onclick="prevStep()" style="visibility:hidden">Back</button>
      <button class="btn-primary" id="btn-next" onclick="nextStep()">Next</button>
    </div>
  </div>

  <script>
    const TOTAL_STEPS = 5;
    const CSRF_TOKEN = ${JSON.stringify(CSRF_TOKEN)};
    const csrfHeaders = { 'x-csrf-token': CSRF_TOKEN };
    let currentStep = 1;
    const toggles = { enableTelegram: true, enableWeb: false };

    function renderProgress() {
      const el = document.getElementById('progress');
      el.innerHTML = '';
      for (let i = 1; i <= TOTAL_STEPS; i++) {
        const dot = document.createElement('div');
        dot.className = 'progress-dot' + (i === currentStep ? ' active' : '') + (i < currentStep ? ' done' : '');
        el.appendChild(dot);
      }
    }

    function showStep(n) {
      currentStep = n;
      document.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
      const step = document.getElementById('step-' + n);
      if (step) step.classList.add('active');
      const nav = document.getElementById('nav');
      if (n >= 6) { nav.style.display = 'none'; return; }
      nav.style.display = 'flex';
      document.getElementById('btn-back').style.visibility = n === 1 ? 'hidden' : 'visible';
      const btnNext = document.getElementById('btn-next');
      btnNext.textContent = n === TOTAL_STEPS ? 'Write .env & Finish' : 'Next';
      btnNext.disabled = false;
      if (n === TOTAL_STEPS) renderSummary();
      renderProgress();
    }

    function nextStep() {
      if (currentStep === 2) {
        const key = document.getElementById('anthropicApiKey').value.trim();
        if (!key) { showV('anthropic-status', 'error', 'Anthropic API key is required'); return; }
        if (!key.startsWith('sk-ant-')) { showV('anthropic-status', 'error', 'Key should start with sk-ant-'); return; }
      }
      if (currentStep === 3) {
        if (toggles.enableTelegram) {
          const token = document.getElementById('telegramBotToken').value.trim();
          if (!token) { showV('telegram-status', 'error', 'Bot token is required when Telegram is enabled'); return; }
          const ids = document.getElementById('allowedUserIds').value.trim();
          if (!ids) { showV('userid-hint', 'error', 'At least one user ID is required (used for access control)'); return; }
          const idParts = ids.split(',').map(function (p) { return p.trim(); }).filter(function (p) { return p.length > 0; });
          if (!idParts.length) {
            showV('userid-hint', 'error', 'Please enter at least one numeric user ID (comma-separated).');
            return;
          }
          var invalidId = idParts.find(function (p) { return !/^[1-9]\d*$/.test(p); });
          if (invalidId) {
            showV('userid-hint', 'error', 'Allowed user IDs must be comma-separated positive integers (e.g. 12345,67890).');
            return;
          }
        }
      }
      if (currentStep === TOTAL_STEPS) { writeConfig(); return; }
      showStep(currentStep + 1);
    }

    function prevStep() { if (currentStep > 1) showStep(currentStep - 1); }

    function toggle(name) {
      toggles[name] = !toggles[name];
      document.getElementById('toggle-' + name).classList.toggle('on', toggles[name]);
      const btn = document.getElementById('btn-' + name);
      if (btn) btn.setAttribute('aria-pressed', String(toggles[name]));
      const fields = { enableTelegram: 'telegram-fields', enableWeb: 'web-fields' };
      if (fields[name]) document.getElementById(fields[name]).style.display = toggles[name] ? '' : 'none';
    }

    function toggleCollapsible(name) {
      document.getElementById('collapsible-' + name).classList.toggle('open');
      document.getElementById('arrow-' + name).classList.toggle('open');
    }

    function showV(id, type, msg) {
      const el = document.getElementById(id);
      el.className = 'validation ' + type;
      el.textContent = msg;
    }

    function maskKey(k) { return (!k || k.length < 10) ? '(not set)' : k.slice(0, 6) + '...' + k.slice(-4); }

    async function validateKey(type) {
      const endpoints = {
        anthropic: ['/api/setup/validate-anthropic', () => ({ key: document.getElementById('anthropicApiKey').value.trim() })],
        openai: ['/api/setup/validate-openai', () => ({ key: document.getElementById('openaiApiKey').value.trim() })],
        telegram: ['/api/setup/validate-telegram', () => ({ token: document.getElementById('telegramBotToken').value.trim() })],
        redis: ['/api/setup/validate-redis', () => ({ url: document.getElementById('redisUrl').value.trim() })],
      };
      const [url, getBody] = endpoints[type];
      const statusId = type + '-status';
      showV(statusId, 'loading', 'Validating...');
      try {
        const r = await fetch(url, { method: 'POST', headers: {'Content-Type':'application/json', ...csrfHeaders}, body: JSON.stringify(getBody()) }).then(r => r.json());
        const msg = r.valid ? (r.botName ? 'Connected as @' + r.botName : type === 'redis' ? 'Redis reachable' : 'Key is valid') : r.error;
        showV(statusId, r.valid ? 'success' : 'error', msg);
      } catch (e) { showV(statusId, 'error', 'Request failed'); }
    }

    function getState() {
      const home = document.getElementById('echosHome').value.trim() || ${JSON.stringify(DEFAULT_ECHOS_HOME).replace(/</g, '\\u003c')};
      return {
        echosHome: home,
        anthropicApiKey: document.getElementById('anthropicApiKey').value.trim(),
        openaiApiKey: document.getElementById('openaiApiKey').value.trim(),
        allowedUserIds: document.getElementById('allowedUserIds').value.trim(),
        enableTelegram: toggles.enableTelegram,
        telegramBotToken: document.getElementById('telegramBotToken').value.trim(),
        enableWeb: toggles.enableWeb,
        webPort: parseInt(document.getElementById('webPort').value) || 3000,
        webApiKey: '',
        redisUrl: document.getElementById('redisUrl').value.trim() || 'redis://localhost:6379',
        knowledgeDir: home + '/knowledge', dbPath: home + '/db', sessionDir: home + '/sessions',
        defaultModel: 'claude-haiku-4-5-20251001', embeddingModel: 'text-embedding-3-small',
        webshareProxyUsername: document.getElementById('webshareProxyUsername').value.trim(),
        webshareProxyPassword: document.getElementById('webshareProxyPassword').value.trim(),
      };
    }

    function renderSummary() {
      const s = getState();
      const table = document.getElementById('summary-table');
      if (!table) return;
      table.innerHTML = '';

      function addRow(label, buildValue) {
        const tr = document.createElement('tr');
        const tdLabel = document.createElement('td');
        tdLabel.textContent = label;
        tr.appendChild(tdLabel);
        const tdValue = document.createElement('td');
        buildValue(tdValue);
        tr.appendChild(tdValue);
        table.appendChild(tr);
      }

      addRow('Data Location', function(td) {
        td.textContent = s.echosHome;
      });
      addRow('Anthropic Key', function(td) {
        const span = document.createElement('span');
        span.className = 'masked';
        span.textContent = maskKey(s.anthropicApiKey);
        td.appendChild(span);
      });
      addRow('OpenAI Key', function(td) {
        const span = document.createElement('span');
        span.className = 'masked';
        span.textContent = s.openaiApiKey ? maskKey(s.openaiApiKey) : '(not set)';
        td.appendChild(span);
      });
      addRow('Telegram', function(td) {
        const span = document.createElement('span');
        span.className = s.enableTelegram ? 'badge badge-on' : 'badge badge-off';
        span.textContent = s.enableTelegram ? 'enabled' : 'disabled';
        td.appendChild(span);
      });
      addRow('Allowed Users', function(td) {
        td.textContent = s.allowedUserIds || '(none)';
      });
      addRow('Web UI', function(td) {
        const span = document.createElement('span');
        if (s.enableWeb) {
          span.className = 'badge badge-on';
          span.textContent = ':' + s.webPort;
        } else {
          span.className = 'badge badge-off';
          span.textContent = 'disabled';
        }
        td.appendChild(span);
      });
      addRow('Redis', function(td) {
        const span = document.createElement('span');
        span.className = 'badge badge-on';
        span.textContent = 'enabled';
        td.appendChild(span);
        td.appendChild(document.createTextNode(' ' + s.redisUrl));
      });
    }

    async function writeConfig() {
      const state = getState();
      if (state.enableWeb && !state.webApiKey) {
        const r = await fetch('/api/setup/generate-key', { method: 'POST', headers: { 'Content-Type': 'application/json', ...csrfHeaders }, body: '{}' }).then(r => r.json());
        state.webApiKey = r.key;
      }
      const btn = document.getElementById('btn-next');
      btn.disabled = true; btn.textContent = 'Writing...';
      try {
        const r = await fetch('/api/setup/write-config', { method: 'POST', headers: {'Content-Type':'application/json', ...csrfHeaders}, body: JSON.stringify(state) }).then(r => r.json());
        if (r.success) showStep(6);
        else { btn.disabled = false; btn.textContent = 'Write .env & Finish'; alert('Error: ' + r.error); }
      } catch (e) { btn.disabled = false; btn.textContent = 'Write .env & Finish'; alert('Failed: ' + (e instanceof Error ? e.message : String(e))); }
    }

    async function startService() {
      const btn = document.getElementById('btn-start-service');
      const status = document.getElementById('start-status');
      btn.disabled = true;
      btn.innerHTML = '<span id="start-icon">⏳</span> Starting...';
      status.style.color = 'var(--text-dim)';
      status.textContent = 'Starting Redis and EchOS daemon...';
      try {
        const r = await fetch('/api/setup/start-service', { method: 'POST', headers: {'Content-Type':'application/json', ...csrfHeaders}, body: '{}' }).then(r => r.json());
        if (r.success) {
          btn.innerHTML = '<span id="start-icon">✓</span> EchOS is running';
          btn.style.background = 'var(--success)';
          status.style.color = 'var(--success)';
          status.textContent = 'EchOS is up! You can close this tab.';
        } else {
          btn.innerHTML = '<span id="start-icon">▶</span> Start EchOS';
          btn.disabled = false;
          status.style.color = 'var(--error)';
          var detail = r && typeof r.error === 'string' && r.error.trim() ? (' Details: ' + r.error.trim()) : '';
          status.textContent = 'Could not start automatically.' + detail + ' You may try running: brew services start redis and brew services start echos';
        }
      } catch (e) {
        btn.innerHTML = '<span id="start-icon">▶</span> Start EchOS';
        btn.disabled = false;
        status.style.color = 'var(--error)';
        var message = (e instanceof Error) ? e.message : String(e);
        status.textContent = 'Could not start automatically. Error: ' + message + ' You may try running: brew services start redis and brew services start echos';
      }
    }

    renderProgress();
  </script>
</body>
</html>`;
}

// ─── Start server ─────────────────────────────────────────────────────────────

// Track connections for graceful shutdown
server.on('connection', (socket) => {
  openSockets.add(socket);
  socket.once('close', () => openSockets.delete(socket));
});

server.on('error', (err: NodeJS.ErrnoException) => {
  if (err.code === 'EADDRINUSE') {
    console.error(`\n  \x1b[31mError:\x1b[0m Port ${PORT} is already in use.\n  Try a different port: PORT=${PORT + 1} pnpm wizard\n`);
  } else {
    console.error(`\n  \x1b[31mServer error:\x1b[0m ${err.message}\n`);
  }
  process.exit(1);
});

server.listen(PORT, '127.0.0.1', () => {
  const url = `http://127.0.0.1:${PORT}/setup`;
  console.log(`\n  \x1b[1m\x1b[36mEchOS Setup\x1b[0m is running at: \x1b[36m${url}\x1b[0m\n`);

  // Try to open browser
  const openCmd = process.platform === 'darwin'
    ? `open "${url}"`
    : process.platform === 'linux'
      ? `xdg-open "${url}" 2>/dev/null || sensible-browser "${url}" 2>/dev/null`
      : '';

  if (openCmd) {
    exec(openCmd, (err) => {
      if (err) {
        console.log(`  Open \x1b[36m${url}\x1b[0m in your browser to continue.\n`);
      }
    });
  }
});
